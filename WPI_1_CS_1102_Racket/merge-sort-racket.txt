;; Hi!
;; After finishing the simpler sorting method, I decided to try to implement merge sort
;; -Ezra

;; Note: In my implementation of merge sort, it starts with two lists (I didn't bother to build a wrapper)
;;     I set up merge-sort this way because BSL doesn't have local variables, so it's much simpler this way

; Natural List -> List
; returns first n items in list where n is Natural
(check-expect (list-head 2 (list 1 2 3 4 5)) (list 1 2))
(check-expect (list-head 6 (list 1 2 3 4 5)) (list 1 2 3 4 5))
(define (list-head num list)
  (cond
    [(empty? list) empty]
    [(<= num 0) empty]
    [else (cons (first list) (list-head (- num 1) (rest list)))]
    ))

;Natural List -> List
(check-expect (drop 2 (list 1 2 3 4 5)) (list 3 4 5))
(check-expect (drop 6 (list 1 2 3 4 5)) empty)
; Returns the list without its first N terms where N is Natural
(define (drop num list)
  (cond
    [(empty? list) empty]
    [(<= num 0) list]
    [else (drop (- num 1) (rest list))]))


;Counts number of items in a list
; Lon -> Natural
(check-expect (count (cons 5 (cons 4 empty))) 2)

(define (count lon)
  (cond [(empty? lon) 0]                   ;BASE CASE
        [else (+ 1
                 (count (rest lon)))]))

;List -> List
;Depends on list-head and count
(check-expect (first-half (list 1 2 3 4 5)) (list 1 2 3))
; Returns the first half of the list
(define (first-half list)
  (list-head (ceiling (/ (count list) 2)) list))

;List -> List
;depends on drop and count
(check-expect (second-half (list 1 2 3 4 5)) (list 4 5))
; Returns the second half of the list
(define (second-half list)
  (drop (ceiling (/ (count list) 2)) list))


;Merges two sorted lists in order
; List List -> List
(check-expect (merge (list 1 3 5) (list 2 4)) (list 1 2 3 4 5))
(check-expect (merge (list 1) (list 2)) (list 1 2))
(check-expect (merge (list 1 3 5 7 9) (list 2 4 6 8 10)) (list 1 2 3 4 5 6 7 8 9 10))
(check-expect (merge empty (list 1 5 6)) (list 1 5 6))
(check-expect (merge (list 1 5 6) empty) (list 1 5 6))
(check-expect (merge empty empty) empty)

(define (merge list1 list2)
  (cond
    [(and (empty? list1) (empty? list2)) empty]
    [(empty? list1) list2]
    [(empty? list2) list1]
    [(> (first list1) (first list2)) (cons (first list2) (merge (rest list2) list1))]
    [(<= (first list1) (first list2)) (cons (first list1) (merge (rest list1) list2))]
    ))





;;Merge sort of numbers (ascending order)
;; LON LON -> LON
;; Depends on: merge, first-half, second-half,
(check-expect (merge-sort empty empty) empty)
(check-expect (merge-sort empty (list 4)) (list 4))
(check-expect (merge-sort (cons 5 (cons 3 empty)) empty) (cons 3 (cons 5 empty)))
(check-expect (merge-sort (list 1 2 3 4 5) (list 6 7 8 9)) (list 1 2 3 4 5 6 7 8 9))
(check-expect (merge-sort (list 1 2 3) (list 1 2 3))(merge-sort (list 3 2 1) (list 3 2 1)))
(check-expect (merge-sort (list 1 3 2 5 4 1110) (list 5 2 999 34 66 9)) (list 1 2 2 3 4 5 5 9 34 66 999 1110))
(check-expect (count (merge-sort (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) empty)) 15)
(check-expect (merge-sort empty (list 1 2)) (list 1 2))

; merge sort
;   If both lists are empty -> empty
;   If one is empty:
;       If the other is 1 long, return it -> List (length: 1)
;       Otherwise (merge-sort it -> list
;   Else (merge (merge-sort list1) (list2)) -> List



(define (merge-sort lon1 lon2)
  (cond
    [(and (empty? lon1) (empty? lon2)) empty] ;returns empty if they are both empty ;not error
    
    [(or (empty? lon1) (empty? lon2)) ; If one is empty, sort the other ; error ?
     (cond
       [(empty? lon1)
        (if (empty? (rest lon2))
            lon2
            (merge-sort (first-half lon2) (second-half lon2))
         )]
       [(empty? lon2)
                (if (empty? (rest lon1))
            lon1
            (merge-sort (first-half lon1) (second-half lon1))
         )]
         )
     ]

    [else ;;Splits each list in half and merges them
     (merge 
           (merge-sort (first-half lon1) (second-half lon1))
           (merge-sort (first-half lon2) (second-half lon2))
           )]
    ))




(merge-sort (list 2 0 8 5 -1 2858790.5 20 247 32789011 -23487 23487 98357 32908457 2908475 9043857 984579 2958472390857 98032457290 48590 93 -23847) empty)
